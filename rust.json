{
	// Place your snippets for rust here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"lis": {
		"prefix": "lis",
		"body": [
			"fn lis<T: Ord + Copy>(an: &[T]) -> usize {",
			"    let mut l = vec![an[0]];",
			"    for a in an.iter().skip(1) {",
			"        if a > l.last().unwrap() {",
			"            l.push(*a);",
			"        } else {",
			"            let i = binary_search_simple(&l, *a);",
			"            l[i] = *a;",
			"        }",
			"    }",
			"    l.len()",
			"}",
		]
	},
	"dfs": {
		"prefix": "dfs",
		"body": [
			"/// edgesは隣接リスト",
			"/// indexは0始まり",
			"fn dfs(edges: &[Vec<usize>]) {",
			"    let mut visited = vec![false; edges.len()];",
			"    for i in 0..edges.len() {",
			"        if visited[i] {continue;}",
			"        let mut stack = vec![i];",
			"        while !stack.is_empty() {",
			"            let now = stack.pop().unwrap();",
			"            for &e in &edges[now] {",
			"                if visited[i] {continue;}",
			"                visited[e] = true;",
			"                stack.push(e);",
			"            }",
			"        }",
			"    }",
			"}",
		]
	},
	"edge create": {
		"prefix": "edge_create",
		"body": [
			"// indexは1始まりを0始まりにする",
			"let mut edges = vec![vec![]; n];",
			"for (_u, _v) in &uv {",
			"    let u = _u - 1;",
			"    let v = _v - 1;",
			"    edges[u].push(v);",
			"    edges[v].push(u);",
			"}",
		]
	},
	"alphabet list": {
		"prefix": "alphabets",
		"body": "let alphabets = (b'A'..=b'Z').map(|c| c as char).collect_vec();",
	},
	"gcd vec 最大公約数": {
		"prefix": "gcd_vec",
		"body": [
			"fn gcd_vec(ns: &[usize]) -> usize {",
			"    ns.iter().fold(0, |gcd, b| integer::gcd(*b, gcd))",
			"}",
		]
	},
	"lcm vec 最小公倍数": {
		"prefix": "lcm_vec",
		"body": [
			"fn lcm_vec(ns: &[usize]) -> usize {",
			"    ns.iter().fold(1, |lcm, b| integer::lcm(*b, lcm))",
			"}",
		]
	},
	"Modulo": {
		"prefix": "modulo",
		"body": [
			"const MOD: isize = 1_000_000_007;",
			"fn modulo(n: isize) -> isize {",
			"    (n % MOD + MOD) % MOD",
			"}",
		],
	},
	"Bit Search": {
		"prefix": "bit_search",
		"body": [
			"$0",
			"/// n要素のbit全探索を行うベクトルを返す",
			"/// [[bool; n]; n^2]",
			"fn bit_search(n: usize) -> Vec<Vec<bool>> {",
			"    let mut sub_list = vec![];",
			"    for bit in 0..(1 << n) {",
			"        let b = (0..n)",
			"            .map(|x| bit & ( 1 << x) != 0)",
			"            .collect();",
			"        sub_list.push(b);",
			"    }",
			"    sub_list",
			"}",
		]
	},
	"Combination Mod": {
		"prefix": "combination_mod",
		"body": [
			"/// nCk mod MODの計算",
			"const MOD: usize = 1_000_000_007;",
			"struct CombinationMod {",
			"    fact: Vec<usize>,",
			"    finv: Vec<usize>,",
			"}",
			"",
			"impl CombinationMod {",
			"    /// nCkを求めるための準備",
			"    fn new(n: usize) -> Self {",
			"        let mut fact = vec![1, 1];",
			"        let mut finv = vec![1, 1];",
			"        let mut inv = vec![0, 1];",
			"",
			"        for i in 2..=n {",
			"            fact.push(fact[i - 1] * i % MOD);",
			"            inv.push(MOD - inv[MOD % i] * (MOD / i) % MOD);",
			"            finv.push(finv[i - 1] * inv[i] % MOD);",
			"        }",
			"",
			"        Self { fact, finv }",
			"    }",
			"",
			"    fn combination(self, n: usize, k: usize) -> usize {",
			"        if n < k {",
			"            0",
			"        } else {",
			"            self.fact[n] * (self.finv[k] * self.finv[n - k] % MOD) % MOD",
			"        }",
			"    }",
			"}",
		]
	},
	"Binary Search": {
		"prefix": "binary_search",
		"body": [
			"$0",
			"/// is_okを満たすindexの中で最もng側に近いindexを返す",
			"/// 配列の大きいほうがOKである必要がある",
			"/// input:",
			"/// - len: 探索対象の配列のサイズ",
			"/// - is_ok: indexが条件を満たすかどうかを返すクロージャ。",
			"/// is_okはindexを受け取り探索対象の配列に対するboolの判定を行う",
			"/// return: okの中で最もng側に近いindexを返す",
			"fn binary_search<F: Fn(usize) -> bool>(len: usize, is_ok: F) -> usize {",
			"    let mut ng: isize = - 1;",
			"    let mut ok: isize = len as isize;",
			"    while (ok - ng).abs() > 1 {",
			"        let mid = ((ok + ng) / 2) as usize; ",
			"        if is_ok(mid) {",
			"            ok = mid as isize;",
			"        } else {",
			"            ng = mid as isize;",
			"        }",
			"    }",
			"    ok as usize",
			"}"
		]
	},
	"Binary Search Simple": {
		"prefix": "binary_search_simple",
		"body": [
			"/// 受け取った配列内でtargetよりも大きい最小のindexを返す",
			"/// - v: 探索対象の配列。単調増加にする",
			"/// - target: 検査対象の数値",
			"fn binary_search_simple<T: std::cmp::PartialOrd>(v: &[T], target: T) -> usize {",
			"    let mut ng: isize = -1;",
			"    let mut ok: isize = v.len() as isize;",
			"    while (ok - ng).abs() > 1 {",
			"        let mid = ((ok + ng) / 2) as usize;",
			"        if v[mid] > target {",
			"            ok = mid as isize;",
			"        } else {",
			"            ng = mid as isize;",
			"        }",
			"    }",
			"    ok as usize",
			"}",
		]
	},
	"Board": {
		"prefix": "board",
		"body": [
			"struct Board<T: Copy> {",
			"    r: usize,",
			"    c: usize,",
			"    board: Vec<Vec<T>>,",
			"    dist: Vec<Vec<isize>>,",
			"}",
			"impl<T: Copy> Board<T> {",
			"    fn new(r: usize, c: usize) -> Self {",
			"        Self::new_with_board(r, c, vec![])",
			"    }",
			"    fn new_with_board(r: usize, c: usize, board: Vec<Vec<T>>) -> Self {",
			"        let dist = vec![vec![-1; c]; r];",
			"        Self { r, c, board, dist }",
			"    }",
			"    fn adjacent_from(&self, p: (usize, usize)) -> Vec<(usize, usize)> {",
			"        let i = p.0;",
			"        let j = p.1;",
			"        [(-1, 0), (1, 0), (0, -1), (0, 1)]",
			"            .iter()",
			"            .map(|(ri, cj)| (i as isize + ri, j as isize + cj))",
			"            .filter(|(ri, cj)| {",
			"                0 <= *ri && *ri < self.r as isize && 0 <= *cj && *cj < self.c as isize",
			"            })",
			"            .map(|(ri, cj)| (ri as usize, cj as usize))",
			"            .collect_vec()",
			"    }",
			"    fn board(&self, p: (usize, usize)) -> T {",
			"        self.board[p.0][p.1]",
			"    }",
			"    fn is_visited(&self, p: (usize, usize)) -> bool {",
			"        self.dist[p.0][p.1] != -1",
			"    }",
			"    fn visit(&mut self, p: (usize, usize), from: (usize, usize)) {",
			"        self.dist[p.0][p.1] = self.dist[from.0][from.1] + 1;",
			"    }",
			"    fn first_visit(&mut self, p: (usize, usize)) {",
			"        self.dist[p.0][p.1] = 0;",
			"    }",
			"    fn dist(&mut self, p: (usize, usize)) -> isize {",
			"        self.dist[p.0][p.1]",
			"    }",
			"    fn reset_visited(&mut self) {",
			"        self.dist = vec![vec![-1; self.c]; self.r];",
			"    }",
			"}",
		]
	},
	"Prime Factorization": {
		"prefix": "prime_factorization",
		"body": [
			"fn prime_factorization(mut n: usize) -> Vec<usize> {",
			"    let mut ps = vec![];",
			"    let mut p = 2;",
			"    while p * p <= n {",
			"        if n % p == 0 {",
			"            ps.push(p);",
			"            n /= p;",
			"        } else {",
			"            p += 1;",
			"        }",
			"    }",
			"",
			"    if n != 1 {",
			"        ps.push(n)",
			"    }",
			"",
			"    ps",
			"}",
		]
	},
	"Power N": {
		"prefix": "power_n",
		"body": [
			"const MOD: usize = 1_000_000_007;",
			"fn power_n(m: usize, n: usize) -> usize {",
			"    if n == 0 {",
			"        1",
			"    } else if n == 1 {",
			"        m",
			"    } else if n % 2 == 0 {",
			"        power_n(m, n / 2) * power_n(m, n / 2) % MOD",
			"    } else {",
			"        (power_n(m, n / 2) * power_n(m, n / 2) % MOD) * m % MOD",
			"    }",
			"}",
		]
	},
	"Topological Sort": {
		"prefix": "topological_sort",
		"body": [
			"/// トポロジカルソートをして返す",
			"/// edgesは隣接リスト",
			"/// 有向グラフで閉路がある場合、変えるVecのサイズが元のサイズよりも小さくなる",
			"fn topological_sort(edges: &[Vec<usize>]) -> Vec<usize> {",
			"    let mut ins= vec![0; edges.len()];",
			"    for edge in edges.iter() {",
			"        for e in edge.iter() {",
			"            ins[*e] += 1;",
			"        }",
			"    }",
			"    let mut stack: Vec<usize> = ins.iter().enumerate().filter(|(_, e)| **e == 0).map(|(i, _)| i).collect();",
			"    let mut sorted = vec![];",
			"    while !stack.is_empty() {",
			"        let n = stack.pop().unwrap();",
			"        sorted.push(n);",
			"        for e in edges[n].iter() {",
			"            ins[*e] -=1;",
			"            if ins[*e] == 0{",
			"                stack.push(*e);",
			"            }",
			"        }",
			"    }",
			"    sorted",
			"}",
		]
	},
	"Segment Tree": {
		"prefix": "segment_tree",
		"body": [
			"struct LazySegmentTree<T, Op> {",
			"    tree: Vec<Option<T>>,",
			"    lazy: Vec<Option<T>>,",
			"    n: usize,",
			"    operator: Op,",
			"}",
			"impl<T, Op> LazySegmentTree<T, Op>",
			"where",
			"    T: Copy,",
			"    Op: Fn(T, T) -> T + Copy,",
			"{",
			"    /// opは親が子の値の何を表すかのクロージャ",
			"    /// 最大値の例）|a: usize, b: usize| -> usize { a.max(b) }",
			"    pub fn new(size: usize, op: Op) -> Self {",
			"        let mut m = size.next_power_of_two();",
			"        if m == size {",
			"            m *= 2;",
			"        }",
			"        Self {",
			"            tree: vec![None; m * 2],",
			"            lazy: vec![None; m * 2],",
			"            n: m,",
			"            operator: op,",
			"        }",
			"    }",
			"    /// 単一のupdate。update_rangeと合わせて使ってしまうとlazyで不整合が起きると思うので使わない",
			"    /// 範囲の更新を行わないのであれば、こちらの方が高速",
			"    pub fn update(&mut self, i: usize, value: T) {",
			"        let mut i = i;",
			"        i += self.n - 1;",
			"        self.tree[i] = Some(value);",
			"        while i > 0 {",
			"            i = (i - 1) / 2;",
			"            let left = self.tree[i * 2 + 1];",
			"            let right = self.tree[i * 2 + 2];",
			"            self.tree[i] = self.op(left, right);",
			"        }",
			"    }",
			"    /// left, right: 探索範囲",
			"    pub fn query(&mut self, left: usize, right: usize) -> Option<T> {",
			"        self.query_sub(left, right + 1, 0, 0, self.n)",
			"    }",
			"    fn eval(&mut self, i: usize) {",
			"        if self.lazy[i].is_none() {",
			"            return;",
			"        }",
			"        // 子供に伝播しておく",
			"        if i < self.n - 1 {",
			"            self.lazy[i * 2 + 1] = self.lazy[i];",
			"            self.lazy[i * 2 + 2] = self.lazy[i];",
			"        }",
			"        self.tree[i] = self.lazy[i];",
			"        self.lazy[i] = None;",
			"    }",
			"    pub fn update_range(&mut self, value: T, left: usize, right: usize) {",
			"        self.update_range_sub(value, left, right + 1, 0, 0, self.n)",
			"    }",
			"    fn update_range_sub(",
			"        &mut self,",
			"        value: T,",
			"        left: usize,",
			"        right: usize,",
			"        i: usize,",
			"        l: usize,",
			"        r: usize,",
			"    ) {",
			"        self.eval(i);",
			"        if r <= left || right <= l {",
			"            // pass",
			"        } else if left <= l && r <= right {",
			"            self.lazy[i] = Some(value);",
			"            self.eval(i);",
			"        } else {",
			"            let mid = (l + r) / 2;",
			"            self.update_range_sub(value, left, right, i * 2 + 1, l, mid);",
			"            self.update_range_sub(value, left, right, i * 2 + 2, mid, r);",
			"            self.tree[i] = self.op(self.tree[i * 2 + 1], self.tree[i * 2 + 2])",
			"        }",
			"    }",
			"    /// left, right: 大元の探索範囲",
			"    /// i: 現在見ているノード",
			"    /// l, r: tree[i]が表している範囲[l,r)の半閉区間",
			"    fn query_sub(&mut self, left: usize, right: usize, i: usize, l: usize, r: usize) -> Option<T> {",
			"        self.eval(i);",
			"        if r <= left || right <= l {",
			"            None",
			"        } else if left <= l && r <= right {",
			"            self.tree[i]",
			"        } else {",
			"            let mid = (l + r) / 2;",
			"            let left_sub = self.query_sub(left, right, i * 2 + 1, l, mid);",
			"            let right_sub = self.query_sub(left, right, i * 2 + 2, mid, r);",
			"            self.op(left_sub, right_sub)",
			"        }",
			"    }",
			"    fn op(&self, a: Option<T>, b: Option<T>) -> Option<T> {",
			"        match (a, b) {",
			"            (Some(a), Some(b)) => Some((self.operator)(a, b)),",
			"            _ => a.or(b),",
			"        }",
			"    }",
			"}",
		]
	},
	"Union Find": {
		"prefix": "union_find",
		"body": [
			"/// UnionFind",
			"/// Union by sizeによる実装",
			"/// ならし計算量はO(α(n))≒O(n)",
			"struct UnionFind {",
			"    parent: Vec<usize>,",
			"    size: Vec<usize>,",
			"}",
			"",
			"impl UnionFind {",
			"    fn new(n: usize) -> Self {",
			"        UnionFind {",
			"            parent: (0..n).collect(),",
			"            size: vec![1; n],",
			"        }",
			"    }",
			"",
			"    fn root(&mut self, x: usize) -> usize {",
			"        if self.parent[x] == x {",
			"            return x;",
			"        }",
			"        self.parent[x] = self.root(self.parent[x]);",
			"        self.parent[x]",
			"    }",
			"",
			"    fn is_same(&mut self, x: usize, y: usize) -> bool {",
			"        self.root(x) == self.root(y)",
			"    }",
			"",
			"    fn unite(&mut self, mut parent: usize, mut child: usize) -> bool {",
			"        parent = self.root(parent);",
			"        child = self.root(child);",
			"",
			"        if parent == child {",
			"            return false;",
			"        }",
			"",
			"        if self.size[parent] < self.size[child] {",
			"            std::mem::swap(&mut parent, &mut child);",
			"        }",
			"",
			"        self.parent[child] = parent;",
			"        self.size[parent] += self.size[child];",
			"        true",
			"    }",
			"",
			"    fn size(&mut self, x: usize) -> usize {",
			"        let root = self.root(x);",
			"        self.size[root]",
			"    }",
			"}"
		]
	}
}